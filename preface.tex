\chapter{Preface}

% what is this book about?
% TAPL has a paragraph describing at a high level what the book is about

% relational programming
% the miniKanren language
% lots of examples



% why am I writing this book?

% language has changed significantly since TRS.
% new constraint operators, and a framework for constraint logic programming cKanren.  also, nominal logic programming, tabling, etc.  These topics are too advanced to easily fit into a second edition of TRS, which in MHO should remain focused on traditional logic programming.  Could have The Constrained Schemer could be a little followup, though.

This is a book about \emph{relational programming}. 
%
Just as functional programs model mathematical functions, relational programs model mathematical relations.
%
Relational\marginnote{If you know nothing about logic programming, relational algebra, or databases, \emph{don't panic!} This book only assumes that you can write simple recursive programs in Scheme.  See the \emph{Audience} section below for details.} programming is intimately related to both logic programming
and relational algebra, the theory behind relational databases.


Relational programs generalize functional programs, in that they do
not distinguish between the ``input'' arguments passed to a function
and the ``output'' result returned by that function.
%
For example, consider a two-argument variant of Scheme's addition function, restricted to natural\marginnote{The \emph{natural numbers} are the non-negative integers: 0, 1, $\ldots$} numbers: \mbox{\scheme|(+ 3 4) => 7|}.
%
A relational version of addition, which we'll call \scheme|+o|, takes three arguments:\marginnote{Here we are taking a notational liberty, as \scheme|+o| expects 3 and 4 to be represented as \emph{binary}, \emph{little-endian} lists: \mbox{\scheme|(1 1)|} and \mbox{\scheme|(0 0 1)|}, respectively. Zero is uniquely represented as the empty list, \scheme|()|.  To ensure a unique representation of each number, lists may not end with the digit \schemeresult|0|.  This numeric representation is extremely flexible, since the lists can contain logic variables---for example, the list \mbox{\scheme|`(1 . ,x)|} represents any odd natural number, while \mbox{\scheme|`(0 . ,x)|} represents any positive even natural. \\ We can also perform relational arithmetic on built-in Scheme numbers, using \emph{Constraint Logic Programming over Finite Domains}, or \emph{CLP(FD)}; CLP(FD) is faster, but less general, than \scheme|+o| and friends (\scheme|*o|, \scheme|/o|, etc.).} \mbox{\scheme|(+o 3 4 z)|},
where \scheme|z| is a \emph{logic variable} that represents the result
of adding the first two arguments of \scheme|+o|. In this case
\scheme|z| is associated with \schemeresult|7|.
%
More interestingly, we can write \mbox{\scheme|(+o 3 y 7)|}, which
associates \scheme|y| with \schemeresult|4|; our addition relation
also performs subtraction.
%
We can also write \mbox{\scheme|(+o x y 7)|}, which associates
\scheme|x| and \scheme|y| with all pairs of natural numbers that sum
to \schemeresult|7|; \scheme|+o| then produces multiple
answers, including \mbox{\scheme|x = 3|} and \mbox{\scheme|y = 4|}, and
\mbox{\scheme|x = 0|} and \mbox{\scheme|y = 7|}.
%
Finally, we can write \mbox{\scheme|(+o x y z)|}, which enumerates 
all triples of natural numbers $(x, y, z)$ such that $x + y = z$; 
here our \scheme|+o| relation produces infinitely many answers.
%
Informally, we say that the +o relation can ``run backwards,'' in
contrast to Scheme's + function, which only can be used in the
``forwards'' direction.

This book will teach you how to write relations that produce
interesting answers when running both forwards and backwards.  For
example, you will learn to write a relational interpreter for a subset
of Scheme: \mbox{\scheme|(evalo '((lambda (x) x) 5) val)|} associates
\scheme|val| with \schemeresult|5|. Of course, we can play more tricks
with \scheme|evalo|: \mbox{\scheme|(evalo exp '6)|} generates legal
Scheme expressions that \emph{evaluate} to 6, while
\marginnote{Douglas Hofstadter coined the term \emph{quine} to describe a program that evaluates to itself, in honor of logician Willard Van Orman Quine (1908--2000).  Writing quines has long been a favorite hacker activity, and quines are often featured in the The International Obfuscated C Code Contest (\url{http://www.ioccc.org/}). Much more on quines can be found in Doug's delightful book, \emph{GEB}: \cite{GEB79}} \mbox{\scheme|(evalo exp exp)|} generates Scheme expressions that evaluate to themselves.

\newpage

%% This\marginnote{The Datalog family of languages is even more closely related to relational databases than the miniKanren language described in this book.  Datalog is more expressive than SQL, but less expressive than miniKanren or Prolog. Datalog is sub-Turing complete, and cannot express infinite computations, which is generally a desireable property for a query language. More on Datalog can be found in: \cite{Ceri:1989:Datalog}} book is about writing programs that ``run backwards.''
%% %
%% Such programs represent mathematical relations; we therefore call them \emph{relational programs}, or just \emph{relations}.
%% %
%% Relational programming is closely related to relational databases, and can also be seen as an especially pure form of logic programming.
%% %
%% The perspective of this book is somewhat different, and is based on generalizing functions to relations. In other words, this book borrows more from functional programming than from logic programming or relational databases.


%% For writing our relational programs, we use the \emph{miniKanren} family of languages.  miniKanren\marginnote{Information on miniKanren, including links to implementations, can be found at the official miniKanren website: \url{http://minikanren.org/}} has been implemented in Scheme, Racket, Clojure (in the form of David Nolen's excellent {\tt core.logic} library), Ruby, Python, and several other ``host'' languages.  miniKanren is designed specifically for relational programming, and makes relational programming easy.

%% Okay, that last part is a lie.  Writing relational programs is $\ldots$ tricky, hence this book.  miniKanren does make relational programming \emph{less difficult} than it would be otherwise.  What \emph{is} true is that writing relational programs is extremely interesting, challenging, and fun.  As in, ``I can write a short, non-obfuscated program that will melt your brain,'' level of fun.


\section{Audience}\label{sec:preface:audience}

\marginnote{\begin{quote}I have attempted to deliver [these lectures] in a spirit that should be recommended to all students embarking on the writing of their PhD theses: imagine that you are explaining your ideas to your former smart, but ignorant, self, at the beginning of your studies!\end{quote}\begin{flushright}\vspace{-1em}---Richard P. Feynman\\\emph{The Feynman Lectures on Computation}\end{flushright}}
This book is written for
intermediate-to-advanced programmers, computer science students, and
researchers.  For this book, \emph{intermediate} means that you are
comfortable writing simple recursive procedures in a functional
programming language, such as Scheme, Racket, Clojure, Lisp, ML, or
Haskell.  I also assume you have a reading knowledge of Scheme.
%
No knowledge of relational programming, logic programming, or programming
language theory is required.

If you want to learn about relational programming, but are new to
programming, Dan Friedman, Oleg Kiselyov, and I have written a book just for you, called
\emph{The Reasoned Schemer}\cite{trs}. In that book we assume you are familiar with the material in \emph{The Little
  Schemer}\cite{Friedman:1996:LS:230223}, which is a very gentle introduction to recursion and
functional programming.

If you are an experienced programmer, but weak on recursion, you, too, might
benefit from \emph{The Little Schemer}.  If you are comfortable with
recursion, but not functional programming, good introductions include
\emph{Scheme and the Art of Programming}\cite{Springer:1989:Art} and
the classic \emph{Structure and Interpretation of Computer
  Programs}\cite{Abelson:1996:SIC:547755}\marginnote{(full text at
\url{http://mitpress.mit.edu/sicp/full-text/book/book.html})}.

If you are an experienced functional programmer, but do not know
Scheme, the beginning of \emph{Structure and Interpretation of
  Computer Programs} should get you up to speed, while \emph{The
  Scheme Programming Language, 4th Edition}\cite{Dybvig:2009:SPL:1618542}\marginnote{(full text at
\url{http://www.scheme.com/tspl4/})} describes the language in detail.


\section{Goals}\label{sec:preface:goals}

% What is the goal of the book?  What do I want the reader to get
% out of the book, think about, or be able to do after reading?

The high-level goals for this book are to make relational programming
accessible to a broader audience, and to explain the state-of-the-art
in the design, implementation, and use of the miniKanren language.

Specifically, this book aims to:

\begin{enumerate}
\item describe the current state of the miniKanren language, and
  its Constraint Logic Programming (CLP) extensions;
\item present a variety of relational programs that exemplify the
  relational style, and that introduce important relational idioms;
\item explain how to derive miniKanren relations from pure Scheme
  functions in a systematic manner;
\item explain in detail the canonical implementation of core miniKanren,
  and show how to hack the implementation to change or extend the
  language;
\item explain how constraint solving works in the cKanren
  Constraint Logic Programming framework, and show how to design and
  implement new constraint domains;
\item demonstrate how to debug miniKanren relations;
\item explain how miniKanren differs from related languages,
  including Prolog, Curry, Mercury, and Oz;
\item describe important open problems in relational programming, and
  limitations of miniKanren;
\item explain the rationale behind key design decisions for miniKanren;
\item use relational programming to explain important and interesting
  concepts from programming languages, such as interpreters, type
  inferencers, and Continuation-Passing Style.
\end{enumerate}

\noindent
An important side-effect of these goals is to provide the background
needed to understand academic papers and talks on miniKanren.


%% One goal of this book is to present a variety of non-trivial
%% miniKanren relations, and to show how these relations were derived.
%% Many of these examples draw from academic papers on miniKanren, and
%% focus on programming languages theory (interpreters, type inferencers,
%% etc.).  Other examples, such as finite state machines, should be of
%% interest to a wider audience of programmers.


% PL-specific terms should be described,
% or at least the reader should be given very specific pointers to
% additional, accessible reading.

% Decribe the current state-of-the-art for relational programming in
% miniKanren.

% Show, in detail, how miniKanren relations can be derived from
% pure Scheme functions.


% Give examples of good relational style.

% Give a more detailed explanation of the miniKanren implementation than is found in TRS or our academic papers.  Show how to hack the implementation to change the behavior of miniKanren, or add new operators.

% Explain how the constraint solving works, and how to design and implement new constraint domains.

% Explain how to debug miniKanren programs.  lol

% Explain the difference between miniKanren and related languages, including Prolog, Curry, Mercury, and Oz.

% Describe the open problems in relational programming, and limitations of miniKanren.

% [Optional]
% Show how to ``play in the mud'' with non-relational features.

% [Optional]
% Explain design decisions made for miniKanren.

% [Optional]
% Give a history of miniKanren (with help from Dan and Oleg)

% [Optional]
% Describe real-world uses of miniKanren.

\section{Margin Notes}\label{sec:preface:margin-notes}

\marginnote{This book is set using the ``Tufte-Style Book''
  \LaTeX\ style, freely available from
  \url{http://www.LaTeXTemplates.com}}
This book is typeset in the style of Edward Tufte's
magnificent and beautiful \emph{The Visual Display of
  Quantitative Information}\cite{Tufte:1986:VDQ:33404}.  I share
Tufte's love of margin notes,\marginnote{Another great lover of
  marginalia was David Foster Wallace (1962--2008).  The \emph{Harry
    Ransom Center}'s DFW collection includes heavily annotated books
  from Wallace's personal library:
  \url{http://www.hrc.utexas.edu/press/releases/2010/dfw/books/}.
  Wallace's love of margin notes is best demonstrated by his essay, 
 ``Host,'' in:\cite{dfw:lobster:2005}} and use them in this book to help solve the problem of addressing readers with
widely varying knowledge of computer science and programming.
%
To make the book accessible as possible, in the main text I assume the
reader is the hypothetical \emph{intermediate-level} programmer or
student described in the \emph{Audience} section above.
%
In the margin notes, however, anything goes.






%   Targeted level of theoretical CS knowledge for existing miniKanren resources
% <----------------------------------------------------------------------------->
% non-existent   basic            intermediate     Undergrad     Graduate     PhD
%                programming      hobbyist         CS            CS           in
%                literacy                          degree        degree       PL
%
%
%              |----------- The Reasoned Schemer -----------|
%
%                                             |---- Weekly Google Hangouts ----|
%
%                                                 |--- My PhD dissertation ----|
%
%                                                 |----- Clojure/conj,
%                                                        Clojure/West,
%                                                        Strange Loop, 
%                                                        Flatmap talks --------|
%
%                                                      |--- Academic Papers ---|
%
%
%                                      |------------ *this book* --------------|
%                                      |--- main text -----|-- margin notes ---|

% Rules: try to target intermediate-to-advanced hobbyists, working
% programmers, and undergrad students in main text.  Allowed to geek
% out in margin notes: anything can go!  Intro chapters and appendices
% will help bring intermediate reader up to speed on CS (and,
% especially, PL-related) topics, such as interpreters, continuations,
% type theory, and program transformations.  This shouldn't be too
% boring, though, since can followup these chapters with the same
% ideas demonstrated relationally (for example, relational
% interpreters, relational CSPer, etc.)  Advanced, optional chapters
% and appendices can explore topics of arbitrary complexity.



%%% SPJ style: describe contributions first.  Then, write to satisfy
%%% the contributions.  I'm done writing once I've backed up all of
%%% the claimed contributions.




%%% I should make sure I have plenty of examples of relational
%%% programming not drawn from PL theory, to make the book more
%%% accessible.  Automata and regex are good examples.  Need to look
%%% for more.  Can borrow some ideas from Prolog books.


% Critical questions that should be answered in the preface:


% Who is the intended audience?  (Always keep this in mind...)  For
% the Little books, the intended reader is a bright but ignorant high
% school student.

% What is the required background of the reader?  Tied closely to the
% first question, obviously.





% quote?

% what is the origin of this book?
% Talk about TRS, thesis, papers, talks, C311/B521

% Goals for the book/what the reader should be able to do after reading the book

% point of view of the book

% language choice/host language/variants of miniKanren

% special instructions to readers?
% what should the reader know?
% typographic conventions?
% how does this book fit in with TRS and my dissertation?
% what parts of this work have previously appeared, and where?

% where can the reader find the code (and the latest version of the
% book)?  How would the reader run the code?

% structure of the book


% Acknowledgements

%% mK developers/co-authors from previous works

%% C311/B521 students

%% IU grad students

%% Google Hangout participants

%% Clojure community

%% creators of Scheme

%% pioneers in logic programming


%% Structure of TAPL preface:
% One para super-brief description of topic of book.
% * \section{Audience}
% * \section{Goals}
% \section{Structure} % (with chapter dependency figure)
% \section{Required Background}
% \section{Course Outlines}
% \section{Exercises}
% \section{Typographic Conventions}
% \section{Electronic Resources}
% \section{Acknowledgements}
% Quotes at the end

\wspace

\noindent
William E. Byrd\\
\noindent
Salt Lake City, Utah\\
\noindent
\monthyear
