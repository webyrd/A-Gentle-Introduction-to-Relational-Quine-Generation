\chapter{Environments}

an environment maps variables to values

we will use an association list representation, with variables represented as symbols

(other representations possible, such as separate flat lists for
variables and values; could use more sophisticated representations in
Scheme, such as tree-based data structures for faster lookup, but this
would complicate the miniKanren implementation significantly)

For example, the environment containing the bindings

$x \rightarrow$ \schemeresult|(foo)|

$y \rightarrow$ \schemeresult|6|

and

$z \rightarrow$ \schemeresult|#t|

might be represented as any of the following association lists (among other possibilities):

\noindent\mbox{\schemeresult|((x . (foo)) (z . #t) (y . 6))|}\footnote{would probably be displayed as \mbox{\schemeresult|((x foo) (z . #t) (y . 6))|}},

\noindent\mbox{\schemeresult|((y . 6) (x . (foo)) (z . #t))|}

\noindent\mbox{\schemeresult|((y . 6) (z . #t) (x . (foo)) (z . 11))|}

\noindent
In the last association list $z$ is bound to \schemeresult|#t|, since the pair \mbox{\schemeresult|(z . #t)|}
occurs in the list before the \emph{shadowed} association \mbox{\schemeresult|(z . 11)|}.


Might write something like this in Scheme:

\begin{schemedisplay}
(define lookup
  (lambda (x env)
    (pmatch env
      (() (error 'lookup "unbound variable"))
      (((,y . ,v) . ,rest)
       (cond
         ((eq? y x) v)
         (else (lookup x rest)))))))
\end{schemedisplay}


\noindent\scheme{(lookup 'z '((z . 5)))} $\Rightarrow$
\begin{schemeresponsebox}5\end{schemeresponsebox}


\noindent\scheme{(lookup 'z '((z . 5) (z . 6)))} $\Rightarrow$
\begin{schemeresponsebox}5\end{schemeresponsebox}


\noindent\scheme{(lookup 'z '((w . 7) (z . 5) (z . 6)))} $\Rightarrow$
\begin{schemeresponsebox}5\end{schemeresponsebox}


However, this version will cause problems if we were to translate it
to miniKanren.  We can see this by noting that the \scheme|cond|
clauses cannot be reordered.  We could fix this by replacing the
\scheme|else| with the negation of the \mbox{\scheme|(eq? y x)|} test
in the previous \scheme|cond| clause.

\begin{schemedisplay}
(define lookup
  (lambda (x env)
    (pmatch env
      (() (error 'lookup "unbound variable"))
      (((,y . ,v) . ,rest)
       (cond
         ((eq? y x) v)
         ((not (eq? y x)) (lookup x rest)))))))
\end{schemedisplay}

Then it would be safe to reorder the \scheme|cond| clauses.  Of course, we can
reorder the \scheme|pmatch| clauses as well:

\begin{schemedisplay}
(define lookup
  (lambda (x env)
    (pmatch env
      (((,y . ,v) . ,rest)
       (cond
         ((not (eq? y x)) (lookup x rest))
         ((eq? y x) v)))
      (() (error 'lookup "unbound variable")))))
\end{schemedisplay}

\noindent\scheme{(lookup 'z '((w . 7) (z . 5) (z . 6)))} $\Rightarrow$
\begin{schemeresponsebox}5\end{schemeresponsebox}

need to make sure each version of lookup is properly tested in the src directory;
should probably break the environment helpers into a separate source code file


better definition: check that \scheme|x| and \scheme|y| are indeed
symbols, and can reorder clauses.  Also arguably cleaner
stylistically, since is doesn't mix \scheme|pmatch| and \scheme|cond|
unnecessarily.  However, there is some duplication in the patterns of
the last two clauses.

\begin{schemedisplay}
(define lookup
  (lambda (x env)
    (unless (symbol? x)
      (error 'lookup "first argument must be a symbol"))
    (pmatch env
      (() (error 'lookup "unbound variable"))
      (((,y . ,v) . ,rest) (guard (symbol? y) (eq? y x))
       v)
      (((,y . ,v) . ,rest) (guard (symbol? y) (not (eq? y x)))
       (lookup x rest)))))
\end{schemedisplay}

Tempting to instead write:

\begin{schemedisplay}
(define lookup
  (lambda (x env)
    (unless (symbol? x)
      (error 'lookup "first argument must be a symbol"))
    (pmatch env
      (() (error 'lookup "unbound variable"))
      (((,x . ,v) . ,rest)
       v)
      (((,y . ,v) . ,rest) (guard (symbol? y) (not (eq? y x)))
       (lookup x rest)))))
\end{schemedisplay}

However, this definition does \emph{not} work, since the \scheme|x| in
the pattern of the second clause shadows the first argument to
\scheme|lookup|

(need more explanation of this; also, this shadowing is at a different
level than the shadowing in an association list)




\begin{schemedisplay}
(define lookupo
  (lambda (x env val)
    (fresh ()
      (symbolo x)
      (matche env
        (((,y . ,v) . ,rest) (symbolo y)
         (== y x) (== v val))
        (((,y . ,v) . ,rest) (symbolo y)
         (=/= y x) (lookupo x rest val))))))
\end{schemedisplay}

\noindent\scheme{(run* (q) (lookupo 'z '((z . 5) (z . 6)) q))} $\Rightarrow$
\begin{schemeresponsebox}(5)\end{schemeresponsebox}

\noindent\scheme{(run* (q) (lookupo 'z '((w . 7) (z . 5) (z . 6)) q))} $\Rightarrow$
\begin{schemeresponsebox}(5)\end{schemeresponsebox}

\noindent\scheme{(run* (q) (lookupo 'y '((x . foo) (y . bar)) q))} $\Rightarrow$
\begin{schemeresponsebox}(bar)\end{schemeresponsebox}

\noindent\scheme{(run* (q) (lookupo 'w '((x . foo) (y . bar)) q))} $\Rightarrow$
\begin{schemeresponsebox}()\end{schemeresponsebox}

\noindent\scheme{(run 5 (q) (lookupo 'z q 5))}

$\Rightarrow$

\begin{schemeresponsebox}
(((z . 5) . _$_{_{0}}$)
 (((_$_{_{0}}$ . _$_{_{1}}$) (z . 5) . _$_{_{2}}$)
  (=/= ((_$_{_{0}}$ z))) (sym _$_{_{0}}$))
 (((_$_{_{0}}$ . _$_{_{1}}$) (_$_{_{2}}$ . _$_{_{3}}$) (z . 5) . _$_{_{4}}$)
  (=/= ((_$_{_{0}}$ z)) ((_$_{_{2}}$ z))) (sym _$_{_{0}}$ _$_{_{2}}$))
 (((_$_{_{0}}$ . _$_{_{1}}$) (_$_{_{2}}$ . _$_{_{3}}$) (_$_{_{4}}$ . _$_{_{5}}$) (z . 5) . _$_{_{6}}$)
  (=/= ((_$_{_{0}}$ z)) ((_$_{_{2}}$ z)) ((_$_{_{4}}$ z))) (sym _$_{_{0}}$ _$_{_{2}}$ _$_{_{4}}$))
 (((_$_{_{0}}$ . _$_{_{1}}$) (_$_{_{2}}$ . _$_{_{3}}$) (_$_{_{4}}$ . _$_{_{5}}$) (_$_{_{6}}$ . _$_{_{7}}$) (z . 5) . _$_{_{8}}$)
  (=/= ((_$_{_{0}}$ z)) ((_$_{_{2}}$ z)) ((_$_{_{4}}$ z)) ((_$_{_{6}}$ z))) (sym _$_{_{0}}$ _$_{_{2}}$ _$_{_{4}}$ _$_{_{6}}$)))
\end{schemeresponsebox}

FIXME: the reified variables don't look like they do in TRS

These \scheme|run| expressions return the same answers if we reorder the \scheme|matche| clauses in \scheme|lookupo|:

\begin{schemedisplay}
(define lookupo
  (lambda (x env val)
    (fresh ()
      (symbolo x)
      (matche env
        (((,y . ,v) . ,rest) (symbolo y)
         (=/= y x) (lookupo x rest val))
        (((,y . ,v) . ,rest) (symbolo y)
         (== y x) (== v val))))))
\end{schemedisplay}
