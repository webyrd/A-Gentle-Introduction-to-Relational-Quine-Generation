\chapter{Environments}

An \emph{environment} maps variables to values.
%
We will use an association list representation, with variables
represented as symbols.\footnote{Other representations of environments
  are certainly possible.  For example, we could use separate flat
  lists of corresponding variables and values.  We could use more
  sophisticated representations in Scheme, such as tree-based data
  structures for faster lookup, but this would complicate the
  miniKanren implementation significantly.}
For example, the environment containing the bindings
%
$x \rightarrow$ \schemeresult|(foo)|,
%
$y \rightarrow$ \schemeresult|6|,
%
and 
%
$z \rightarrow$ \schemeresult|#t|
%
might be represented as any of the following association lists (among other possibilities):

\noindent\mbox{\schemeresult|((x . (foo)) (z . #t) (y . 6))|}\footnote{This association list would be displayed in most Scheme implementations as \mbox{\schemeresult|((x foo) (z . #t) (y . 6))|}.},

\noindent\mbox{\schemeresult|((y . 6) (x . (foo)) (z . #t))|}

\noindent\mbox{\schemeresult|((y . 6) (z . #t) (x . (foo)) (z . 11))|}

\noindent
In the last association list $z$ is bound to \schemeresult|#t|, since the pair \mbox{\schemeresult|(z . #t)|}
occurs in the list before the \emph{shadowed} association \mbox{\schemeresult|(z . 11)|}.

To look up the value bound to a variable, we will use the \scheme|lookup| function:

\noindent\scheme{(lookup 'z '((z . 5)))} $\Rightarrow$
\begin{schemeresponsebox}5\end{schemeresponsebox}

\noindent\scheme{(lookup 'z '((z . 5) (z . 6)))} $\Rightarrow$
\begin{schemeresponsebox}5\end{schemeresponsebox}

\noindent\scheme{(lookup 'z '((w . 7) (z . 5) (z . 6)))} $\Rightarrow$
\begin{schemeresponsebox}5\end{schemeresponsebox}

A straight-forward definition of \scheme|lookup| in Scheme using
pattern matching might look like this:

\begin{schemedisplay}
(define lookup
  (lambda (x env)
    (pmatch env
      (() (error 'lookup "unbound variable"))
      (((,y . ,v) . ,rest)
       (cond
         ((eq? y x) v)
         (else (lookup x rest)))))))
\end{schemedisplay}

However, this definition of \scheme|lookup| would cause trouble if we
were to translate it to miniKanren.  This is because of the use of the
\scheme|else| auxilliary keyword in the second \scheme|cond| clause.
We could fix this by replacing the \scheme|else| with the explicit
negation of the \mbox{\scheme|(eq? y x)|} test in the previous
\scheme|cond| clause.

\begin{schemedisplay}
(define lookup
  (lambda (x env)
    (pmatch env
      (() (error 'lookup "unbound variable"))
      (((,y . ,v) . ,rest)
       (cond
         ((eq? y x) v)
         ((not (eq? y x)) (lookup x rest)))))))
\end{schemedisplay}

Then it would be safe to reorder the \scheme|cond| clauses.  Of
course, we can reorder the \scheme|pmatch| clauses as well

\begin{schemedisplay}
(define lookup
  (lambda (x env)
    (pmatch env
      (((,y . ,v) . ,rest)
       (cond
         ((not (eq? y x)) (lookup x rest))
         ((eq? y x) v)))
      (() (error 'lookup "unbound variable")))))
\end{schemedisplay}

and the tests still pass:

\noindent\scheme{(lookup 'z '((w . 7) (z . 5) (z . 6)))} $\Rightarrow$
\begin{schemeresponsebox}5\end{schemeresponsebox}

Before translating the \scheme|lookup| function into a miniKanren
relation, we can make two more improvements.  First, we should check
that \scheme|x| and \scheme|y| are indeed symbols.  We can do this by
adding appropriate calls to the \scheme|symbol?| predicate.  Second,
it is arguably cleaner stylistically to avoid the \scheme|cond| form
by adding another \scheme|pmatch| clause, at the cost of a duplicate
\scheme|pmatch| pattern.

\begin{schemedisplay}
(define lookup
  (lambda (x env)
    (unless (symbol? x)
      (error 'lookup "first argument must be a symbol"))
    (pmatch env
      (() (error 'lookup "unbound variable"))
      (((,y . ,v) . ,rest) (guard (symbol? y) (eq? y x))
       v)
      (((,y . ,v) . ,rest) (guard (symbol? y) (not (eq? y x)))
       (lookup x rest)))))
\end{schemedisplay}

It is tempting to instead write:

\begin{schemedisplay}
(define lookup
  (lambda (x env)
    (unless (symbol? x)
      (error 'lookup "first argument must be a symbol"))
    (pmatch env
      (() (error 'lookup "unbound variable"))
      (((,x . ,v) . ,rest)
       v)
      (((,y . ,v) . ,rest) (guard (symbol? y) (not (eq? y x)))
       (lookup x rest)))))
\end{schemedisplay}

The second \scheme|pmatch| clause matches against an association list
containing an association between \scheme|x| and \scheme|v|.  However,
this definition of \scheme|lookup| does not work properly, since the
\scheme|x| in the pattern of the second clause shadows the \scheme|x|
that appears as the first argument to \scheme|lookup|.  Indeed, we
could replace the \scheme|x| in the \mbox{\scheme|(,x . ,v)|}
association with almost any variable name\footnote{We cannot change
  \scheme|x| to either \scheme|v| or \scheme|rest|, since this would
  change the structure of the pattern in the second clause.  For
  example, changing \scheme|x| to \scheme|v| results in the pattern
  \mbox{\scheme|((,v . ,v) . ,rest)|} which matches against
  \mbox{\scheme|((z . z) (y . 3))|}, but not against \mbox{\scheme|((z
    . 5) (y . 3))|}.} without changing the behavior of the second
clause.


\begin{schemedisplay}
(define lookupo
  (lambda (x env val)
    (fresh ()
      (symbolo x)
      (matche env
        (((,y . ,v) . ,rest) (symbolo y)
         (== y x) (== v val))
        (((,y . ,v) . ,rest) (symbolo y)
         (=/= y x) (lookupo x rest val))))))
\end{schemedisplay}

\noindent\scheme{(run* (q) (lookupo 'z '((z . 5) (z . 6)) q))} $\Rightarrow$
\begin{schemeresponsebox}(5)\end{schemeresponsebox}

\noindent\scheme{(run* (q) (lookupo 'z '((w . 7) (z . 5) (z . 6)) q))} $\Rightarrow$
\begin{schemeresponsebox}(5)\end{schemeresponsebox}

\noindent\scheme{(run* (q) (lookupo 'y '((x . foo) (y . bar)) q))} $\Rightarrow$
\begin{schemeresponsebox}(bar)\end{schemeresponsebox}

\noindent\scheme{(run* (q) (lookupo 'w '((x . foo) (y . bar)) q))} $\Rightarrow$
\begin{schemeresponsebox}()\end{schemeresponsebox}

\noindent\scheme{(run 5 (q) (lookupo 'z q 5))}

$\Rightarrow$

\begin{schemeresponsebox}
(((z . 5) . _.0)
 (((_.0 . _.1) (z . 5) . _.2)
  (=/= ((_.0 z))) (sym _.0))
 (((_.0 . _.1) (_.2 . _.3) (z . 5) . _.4)
  (=/= ((_.0 z)) ((_.2 z))) (sym _.0 _.2))
 (((_.0 . _.1) (_.2 . _.3) (_.4 . _.5) (z . 5) . _.6)
  (=/= ((_.0 z)) ((_.2 z)) ((_.4 z))) (sym _.0 _.2 _.4))
 (((_.0 . _.1) (_.2 . _.3) (_.4 . _.5) (_.6 . _.7) (z . 5) . _.8)
  (=/= ((_.0 z)) ((_.2 z)) ((_.4 z)) ((_.6 z))) (sym _.0 _.2 _.4 _.6)))
\end{schemeresponsebox}

These \scheme|run| expressions return the same answers for these queries if we reorder the \scheme|matche| clauses in \scheme|lookupo|:

\begin{schemedisplay}
(define lookupo
  (lambda (x env val)
    (fresh ()
      (symbolo x)
      (matche env
        (((,y . ,v) . ,rest) (symbolo y)
         (=/= y x) (lookupo x rest val))
        (((,y . ,v) . ,rest) (symbolo y)
         (== y x) (== v val))))))
\end{schemedisplay}




\setbox\boxa\vtop{{\footnotesize
\begin{schemebox}
(defmatche (lookupo x env val)
  ((,x ((,x . ,val) . ,rest) ,val)
   (symbolo x))
  ((,x ((,y . ,v) . ,rest) ,val)
   (symbolo x) (symbolo y)
   (=/= x y) (lookupo x rest val)))
\end{schemebox}}}

\footnote{Alternatively, we could define \scheme|lookupo| using \scheme|defmatche|, which arguably results in a cleaner definition: \\ \ \\ \usebox{\boxa} \\ \ \\ However, this definition does not as clearly reflect the structure of the \scheme|lookup| function defined using \scheme|pmatch|.}
