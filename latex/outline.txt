-*- mode: org -*-

(Try organizing book based on how I give talks on miniKanren)
(Book as text for intensive summer school course)

Outline to the paragraph level, with topic sentences and sentences describing what goes in the para.  (As I did with my dissertation.)


[where to introduce =/=/symbolo/numbero/absento/matche/CLP(fd) ?]

[where to put this?  logic programming vs. relational programming (have spoken about it in several interviews, including the InfoQ video at Code Mesh)]

[where should these go?]
  [nominal logic programming?]
  [CLP(fd)?  sodoku?  N-queens?]
  [meta-interpreters]
  [negation]


* introduction: relational view of programming 
[have already written about this in the attic, and spoke about this at Lambda Lounge Utah]
** + vs +o
* intro to core mk
3 logical operators and 1 interface operator
** ==  (binary function; syntactic equality; similar in spirit to equal?; really a constraint, rather than a Scheme predicate: asserts equality, rather than just testing for it; success (== 5 5) vs. failure (== 5 6); does (== 5 x) hold?  Depends on the value of x; == works on terms: atoms, pairs of terms, and logic variables; (== 5 5) is not a complete miniKanren program: evaluates to a Scheme procedure)  [need to be careful to make a distinction between logic variables and normal Scheme lexical variables]
** run (interface between Scheme and miniKanren (interface operator, as opposed to logical operator); (run 1 (q) (== 5 5)) => (_.0)   1: number of answers we want (if that many answers exist); q: query variable (could be any identifier, but by convention we tend to use q); body of run (goal constructor); returns a list of answers
** fresh (introduce logic variables; implicit conjunction in the body)
** conde (disjunction; resembles Scheme's cond form; actually, disjunction of conjunctions; unlike with cond, all clauses can produce answers; also, nothing special about the first goal-constructing expression (as opposed to conda and condu))

* translating from Scheme to minikanren
** appendo
'else' and Dijkstra guards; run backwards; ordering of conjuncts and disjuncts; equivalence of divergence and finite failure; complete search -> will find answers that exist (in theory, at least; might run out of memory, or might take a trilion years)
** rembero
show it working; show the problem; need to guard the second clause (no overlapping principle); =/= to the rescue (should =/= be introduced earlier?  Maybe not.  Might be better to introduce as needed, as long as I have sufficient cross refs throughout book)

* three ways to represent numbers
** Peano numerals
*** Decidability/Presburger vs. Peano arithmetic
** Oleg numbers
** CLP(fd)
** tradeoffs/uses of the three representations
Peano useful for inductive proofs
Oleg numbers very general, and much more efficient than Peano representation
CLP(fd) very efficient, but less flexible; reification can force enumeration instead of giving a more general answer (fix this!)
* Chomsky hierarchy
** finite automata
show how to use mutual recursion to encode automata
** Deterministic Finite Automata
** Non-deterministic Finite Automata
non-determinism "for free"
** pushdown automata
add a stack
non-deterministic by default
** Turing machine
** environment-passing interpreter: CBV lambda-calculus
equivalent in expressive power to TM
*** lambda-calculus
*** CBV
*** environments
*** closures
show running backwards
*** extend with list and quote
**** 99 ways to say (I love you) [pointer to Matt's blog post]
*** quines (thanks Stu!)
*** twines
*** thrines
*** extended interpreter, with Oleg numbers and cons/car/cdr, if, zero?, etc.
**** programs that evaluate to 6
**** 99 ways to say (I love you), revisited

* combinatory logic
** combinator synthesis
*** fixpoint combinators
**** U-combinator hint

* type inference
** type inhabitation
** Curry-Howard
** Hindley Milner
*** polymorphic let
**** performance tradeoffs

* playing dirty (conda/condu/project)
** how to play dirty
** why playing dirty is nasty

* implementation of uK/mK//
** uK
** mK
** constraints
*** =/=
*** symbolo
*** numbero
*** absento
*** CLP(fd)
* Appendix: intro to Scheme
