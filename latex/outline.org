* Part I: Introduction to miniKanren
** Core miniKanren
*** ==
*** run
*** fresh
*** conde
** Scheme as a Host Language
*** Values
*** Fun with Recursion
** Divergence and Negation
** Translating Simple Scheme Functions to miniKanren Relations [hand-wavy approach]
*** append
*** rember [aka, surpriseo!]
*** [a couple other examples using only core miniKanren]
** Additional Constraints
*** =/=
**** rember Reconsidered
*** symbolo and numbero
** Representing Numbers in miniKanren
*** Peano Arithmetic]
*** Oleg Numbers
*** CLP(fd)
*** Tradeoffs between number systems
** Hueristics for Translating Scheme to miniKanren
**** Non-overlapping Principle
**** Translating Predicates
** A More Mechanical Approach
**** A-Normal Form
**** Defunctionalization
**** Pattern Matching
***** Enforcing non-overlapping
**** Handling Negation
***** =/= and other constraints
***** Helper Relations
**** Examples
***** append
***** [more interesting examples, including at least one with negation]

* Part II: Exploring the Chomsky Hierarchy
** Regular Expression Matching
** Deterministic Finite Automata
** Relational Exploration of Programming Languages Fundamentals
*** Lexical Scope
*** Relational Program Transformations
** Relational Interpreters
*** Relational Scheme Interpreter
**** Generating Quines
** Type Inference
*** Type Inhabitation

* Part III: Implementation
** Unification and substitutions
** Reification
** muKanren
** Building miniKanren on top of muKanren
** Tabling
** Adding constraints other than unification
*** Example 1: Adding disequality constraints
*** Example 2: Adding symbolo and numbero
*** Adding other constraints
