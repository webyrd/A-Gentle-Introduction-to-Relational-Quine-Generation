* Part I: Introduction to miniKanren
** Core miniKanren
*** ==
*** run
*** fresh
*** conde
*** Properties of reified answers
*** Simple examples
** Scheme as a host language
*** Values
*** Fun with recursion
*** Mixing Scheme and miniKanren
** Divergence and negation
** Translating simple Scheme functions to miniKanren relations [hand-wavy approach]
*** append
*** rember [aka, surpriseo!]
*** [a couple other examples using only core miniKanren]
** Additional constraints
*** =/=
**** rember reconsidered
*** symbolo and numbero
*** absento
*** eigen
** Representing numbers in miniKanren
*** Peano arithmetic
*** Oleg numbers
*** CLP(fd)
*** Choosing which number system to use
** Hueristics for translating Scheme to miniKanren
**** Non-overlapping principle
**** Translating predicates
***** An exception: intentional generating "erroneous" inputs
** A more mechanical approach
**** A-Normal form
**** Defunctionalization
**** Pattern matching
***** Enforcing non-overlapping
**** Handling negation
***** =/= and other constraints
***** Helper relations
**** Examples
***** append
***** [more interesting examples, including at least one with negation]
* Part II: Exploring the Chomsky Hierarchy
** Regular expression matching
** Deterministic finite automata
** Relational exploration of programming languages fundamentals
*** Lexical scope
*** Relational program transformations
** Relational interpreters
*** Relational Scheme interpreter
**** Generating Quines
** Type inference
*** Type inhabitation
* Part III: Implementation
** Unification and substitutions
** Reification
** microKanren
** Building miniKanren on top of microKanren
** Alternate run interfaces
** Tabling
** Adding constraints other than unification
*** Example 1: Adding disequality constraints
*** Example 2: Adding symbolo and numbero
*** Adding other constraints



History of miniKanren

miniKanren resources

miniKanren design decisions and tradeoffs
