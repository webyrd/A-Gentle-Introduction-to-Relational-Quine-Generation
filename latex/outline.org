look at: dissertation, papers, summer school, miniKanren.org, blog
posts, core.logic pages, tutorials, videos of talks I've given, etc.

think about how I normally present these ideas to people


[where to put? these]

History of miniKanren

miniKanren resources

miniKanren design decisions and tradeoffs



* Part I: Introduction to miniKanren
** Core miniKanren
*** ==
*** run
*** fresh
*** conde
*** Properties of reified answers
*** Simple examples
** Scheme as a host language
*** Values
*** Fun with recursion
*** Mixing Scheme and miniKanren
** Translating simple Scheme functions to miniKanren relations [hand-wavy approach]
*** append
hello world of logic programming
example of append in Scheme
add an 'o' to the name
add an 'out' argument (and why this is not the best name)
cond becomes conde
(null? l) becomes (== '())
values that were previously returned are now
run it forward
run it backwards, sideways, etc
divergence!
reordering of goals
*** rember [aka, surpriseo!]
*** [a couple other examples using only core miniKanren]
** Additional constraints
*** =/=
**** rember reconsidered
*** symbolo and numbero
*** absento
*** eigen
** Divergence and negation
*** Different types of divergence
*** Techniques and tricks for apparently divergent queries
** Representing numbers in miniKanren
*** Peano arithmetic
*** Oleg numbers
*** CLP(fd)
[do we even have an implementation of mK with the other constraints, which also has CLP(fd)?  sigh]
*** Choosing which number system to use
[stupid reification of CLP(fd) is part of the problem here--our reifier is too eager]
** Hueristics for translating Scheme to miniKanren
**** Non-overlapping principle
**** Translating predicates
**** Recursive goals should come last in a fresh or run, or within a conde clause
**** Non-recursive clauses should come first in a conde
***** An exception: intentional generating "erroneous" inputs
** A more mechanical approach
**** A-Normal form
**** Defunctionalization
**** Pattern matching
***** Enforcing non-overlapping
**** Handling negation
***** =/= and other constraints
***** Helper relations
**** Examples
***** append
***** [more interesting examples, including at least one with negation]
** Debugging miniKanren programs
* Part II: Exploring the Chomsky Hierarchy
** Regular expression matching
** Deterministic finite automata
** Relational exploration of programming languages fundamentals
*** Lexical scope
*** Relational program transformations
** Relational interpreters
*** Relational Scheme interpreter
**** Generating Quines
** Type inference
*** Type inhabitation
* Part III: Implementation
** Unification and substitutions
** Reification
** microKanren
** Building miniKanren on top of microKanren
** Alternate run interfaces
** Tabling
** Adding constraints other than unification
*** Example 1: Adding disequality constraints
*** Example 2: Adding symbolo and numbero
*** Adding other constraints
