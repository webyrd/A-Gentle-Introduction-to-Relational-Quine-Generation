OUTLINE FOR 'SMALL' BOOK--JUST INTRODUCING THE QUINES-GENERATING INTERPRETER

THE PRIME DIRECTIVE

Stick to the goal: ensure the reader fully understands how the
relational interpreter works.  in particular, the reader should be
able to modify or extend the relational interpreter, or implement a
relational interpreter for another langugae.  Anything that doesn't
advance this goal must be cut, put in a margin note, made an exercise,
or moved to an appendix.

MAJOR QUESTIONS/ISSUES

Do I want to include an mK implementation section?  I think not.  Want
to keep this a small, very directed book.

Seems like there a tension bewteen an overwhelming amount of detail,
and too much mystery.  I think I'll err on the too much mystery side
for now, then add the minimum relevant details once readers start
giving me feedback.

EXERCISES (might just turn some of these into actual sections of the book, with full explanations and derivations)

Scheme
------

miniKanren
----------

extending relational interpreter
--------------------------------

add null?, cons, car, cdr
then implement 'append' using Y combinator, and make it run backwards

add if

add letrec

add numbers, sub1, *, and implement factorial using Y combinator

implement an interpreter for a language other than Scheme

=================================


look at: dissertation, papers, summer school, miniKanren.org, blog
posts, core.logic pages, tutorials, videos of talks I've given, etc.

think about how I normally present these ideas to people

figure out which examples, and what code, goes where



Title:
How to Write a Relational Scheme Interpreter in miniKanren


* Preface
** Goal
ensure the reader fully understands how the relational interpreter
works.  in particular, the reader should be able to modify or extend
the relational interpreter, or implement a relational interpreter for
another langugae.  Anything that doesn't advance this goal has been
cut, put in a margin note, made an exercise, or moved to an appendix.
** Audience
for the small book, want to make it as accessible and self-contained
as possible.  for that reason, will start the book with a brief intro
to functional programming in Scheme, introducing only the minimal
aspects of the language needed to write and understand the relational
interpreter
** Running the code
[especially for this short book, might want to have all code runnable
online, using Nada's tech.  Could have this code/configuration/etc. in
a GitHub repo for posterity.  Of course, should also have code by
itself in a repo.  Ideally code should run under Vicare, Chez, Racket,
Gambit, Chicken, Larceny, etc.  Have compatibility modes for each
impl.  Might need some infrastructure so I can test code under
multiple imples from the command line]
** Typographical conventions
[can massage the typographical conventions text from my dissertation
(section 1.5)]
** miniKanren resources
** Margin notes
** Acknowledgements
* Just enough Scheme
* Introduction to core miniKanren
** The core operators
*** ==
*** run
*** fresh
*** conde
** Properties of reified answers
** Simple examples
** Fun with recursion
** Mixing Scheme and miniKanren

[got down to here.  after this, needs to be reworked]

* Translating Scheme functions to miniKanren relations
** append
hello world of logic programming
example of append in Scheme
add an 'o' to the name
add an 'out' argument (and why this is not the best name)
cond becomes conde
(null? l) becomes (== '())
values that were previously returned are now
run it forward
run it backwards, sideways, etc
divergence!
reordering of goals
** rember [aka, surpriseo!]
** member
*** Rules for translating a predicate
When translating a predicate, is is usually best to represent true as success, and false as failure
This means no 'out' argument.  Also, conde clauses that fail can be removed
member shows similar behavior to rember/surpriseo
Is is possible to use an 'out' argument to explicitly represent true and false;
this may be slower, and may make the code longer and more complicated, but has 
the advantage of being able to synthesize input values that result in false
** [a couple other examples using only core miniKanren]
** Translating impure Scheme programs
*** Errors are represented as failure
** An informal algorithm for translating Scheme programs to miniKanren
* Additional constraints
** =/=
*** rember reconsidered
can fix member in a similar fashion
** symbolo and numbero
** absento
** eigen
* Divergence and negation
** Different types of divergence [based on Chapter 5 in my dissertation ('A Slight Divergence')]
[need to make sure this section very clearly focuses on divergence vs. finite failure;  I'm not sure organization based on 'A Slight Divergence' works best, especially since it depends on detailed knowledge of the implementation, which hasn't been presented yet.  Although the topics discussed in that chapter are important, and should appear in the book]
could include margin note on how reification can diverge is we allow circularities by removing the occur check in unification
could then point out how unification could be extended to handle 'rational' trees, in which both unification and the reifier allow circularities without a problem
also could include margin note on depth-first search being incomplete, and showing an example where that causes divergence
*** run* with an unbounded number of answers
*** run n where there are fewer than n answers
**** Finite failure vs. divergence
(run 1 (q) (fresh () alwayso fail)) is the canonical example
** Techniques and tricks for apparently divergent queries
* Hueristics for translating Scheme to miniKanren
*** Non-overlapping principle
*** Conde clauses that always fail can be removed
may improve divergence behavior for some queries
*** Translating predicates
*** Recursive goals should come last in a fresh or run, or within a conde clause
*** Non-recursive clauses should come first in a conde
*** Handling negation
**** =/= and other constraints
**** Helper relations
* Debugging miniKanren programs

* A Simple Scheme Interpreter in Scheme
** Lexical scope
*** Free & Bound Variables
*** Lexical Environments
** A Simple Scheme Interpreter
* Writing an Interpreter in Relational Style
** Relational Scheme interpreter
* Extending the Relational Interpreter
** Adding quote
** Adding list
** (I love you)
** Generating Quines, Twines and Thrines
* Adding pair-related functions
** Adding null?
** Adding cons
** Adding car & cdr
** Running append backwards
use Y combinator
runs backwards, forward, etc
slower, but with the same divergence behavior as the 'good' version of appendo
interesting aspect: the relational aspect is in the interpreter, *not* in the definition of append
* Adding numbers to the interpreter
** Oleg numbers
** Arithmetic operators
** Divergence behavior of the arithmetic system
** 
