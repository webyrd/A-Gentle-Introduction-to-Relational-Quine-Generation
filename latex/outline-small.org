OUTLINE FOR 'SMALL' BOOK--JUST INTRODUCING THE QUINES-GENERATING INTERPRETER

THE PRIME DIRECTIVE

Stick to the goal: ensure the reader fully understands how the
relational interpreter works.  in particular, the reader should be
able to modify or extend the relational interpreter, or implement a
relational interpreter for another langugae.  Anything that doesn't
advance this goal must be cut, put in a margin note, made an exercise,
or moved to an appendix.

MAJOR QUESTIONS/ISSUES

Do I want to include an mK implementation section?  I think not.  Want
to keep this a small, very directed book.

Seems like there a tension bewteen an overwhelming amount of detail,
and too much mystery.  I think I'll err on the too much mystery side
for now, then add the minimum relevant details once readers start
giving me feedback.

EXERCISES (might just turn some of these into actual sections of the book, with full explanations and derivations)

Scheme
------

miniKanren
----------

extending relational interpreter
--------------------------------

add null?, cons, car, cdr
then implement 'append' using Y combinator, and make it run backwards

add if

add letrec

add numbers, sub1, *, and implement factorial using Y combinator

implement an interpreter for a language other than Scheme

=================================


look at: dissertation, papers, summer school, miniKanren.org, blog
posts, core.logic pages, tutorials, videos of talks I've given, etc.

think about how I normally present these ideas to people

figure out which examples, and what code, goes where


IMPORTANT:

talk about shadowing of built-ins for the relational interpreter

point out that even if we allow shadowing, we are treating 'list' (for
example) specially as a 'built-in', since we can't write things like:

((lambda (x) (x x)) list)

(which returns (#<procedure list>) in Vicare).  This is because 'list'
isn't bound in the initial environment.  Should also show how to add
list, cons, etc., to the initial environment.  Do I actually know how
to do this/the right way to do this?


Point out that the mk interpreter will fail for Scheme programs that
would signal errors in Scheme (due to referencing unbound variables,
dividing by zero, wrong number of arguments to an application, etc.).
In some cases, programs that would diverge in Scheme will fail
finitely under the relational interpreter.  For example,

(evalo `(cons ((lambda (x) (x x)) (lambda (x) (x x))) 5) 6)

should fail finitely, since the relational reducer can fail as soon as
it recognizes that the outermost expression is a call to 'cons', yet
the output isn't a pair.  So, failure in mk is a proof that the input
expression cannot evaluate to the specified output value.


FAILING FAST BY PEEKING UNDER LAMBDAS

Michael Ballantyne pointed out today (26 June 02014) that we can
"peek" under the lambda in the interpreter, which can also lead to
fail-fast behavior.  For example,

(evalo `((lambda (x) 5) ((lambda (x) (x x)) (lambda (x) (x x))) 6)

should fail finitely, if we peek under the lambda in (lambda (x) 5);
clearly, there is no way the body of this lambda expression can
evaluate to the specified output value, 6.  Therefore, there is no
need to evaluate omega before performing the beta step, even under
call-by-value lambda semantics.

Not sure how much I want to get into the peeking under lambdas
optimization in the main text.  Would make a good marginnote, at
least.  Maybe it's worth exploring in 'Other Extensions'.







??? Is any of this in scope?
----------------------------
call-by-value vs call-by-name vs call-by-need
alpha-equivalence
naive vs capture-avoiding substitution
environments vs substitution
beta reduction
eta-expansion/eta-reduction
----------------------------
seems like some of these topics are important from a context/design
decision standpoint.  could potentially include a combinatory logic
reducer, a CBV small-step reducer for Scheme using naive substitution,
and the big-step interpreter.  Could even include a big-step
call-by-name reducer for lambda calculus, using nominal logic.  Is
this too much?  All of these topics seem related, and to some extent
you can't fully understand one of these interpreters/reducers without
understanding the alternatives.  May be too much, though.




Title:
How to Write a Relational Scheme Interpreter in miniKanren


* Preface
** Goal
ensure the reader fully understands how the relational interpreter
works.  in particular, the reader should be able to modify or extend
the relational interpreter, or implement a relational interpreter for
another langugae.  Anything that doesn't advance this goal has been
cut, put in a margin note, made an exercise, or moved to an appendix.
** Audience
for the small book, want to make it as accessible and self-contained
as possible.  for that reason, will start the book with a brief intro
to functional programming in Scheme, introducing only the minimal
aspects of the language needed to write and understand the relational
interpreter
** Running the code
[especially for this short book, might want to have all code runnable
online, using Nada's tech.  Could have this code/configuration/etc. in
a GitHub repo for posterity.  Of course, should also have code by
itself in a repo.  Ideally code should run under Vicare, Chez, Racket,
Gambit, Chicken, Larceny, etc.  Have compatibility modes for each
impl.  Might need some infrastructure so I can test code under
multiple imples from the command line]
** Typographical conventions
[can massage the typographical conventions text from my dissertation
(section 1.5)]
** miniKanren resources
** Margin notes
** Acknowledgements
* PART I: INTRODUCTION TO SCHEME AND MINIKANREN
* Just enough Scheme
** Lexical scope
[will need this later for the interpreter]
*** Free & Bound Variables
* Introduction to core miniKanren
** The core operators
*** ==
*** run
*** fresh
*** conde
** Properties of reified answers
** Simple examples
** Fun with recursion
** Divergence
** Mixing Scheme and miniKanren

[got down to here.  after this, needs to be reworked]

* Translating simple Scheme functions to miniKanren relations
** append
hello world of logic programming
example of append in Scheme
add an 'o' to the name
add an 'out' argument (and why this is not the best name)
cond becomes conde
(null? l) becomes (== '())
values that were previously returned are now
run it forward
run it backwards, sideways, etc
divergence!
reordering of goals
** rember [aka, surpriseo!]
*** Errors are represented as failure
** An informal algorithm for translating Scheme programs to miniKanren
* Extended miniKanren
** =/=
*** rember reconsidered
can fix member in a similar fashion
** symbolo and numbero
** absento
* Hueristics for translating Scheme to miniKanren
*** Non-overlapping principle
*** Conde clauses that always fail can be removed
may improve divergence behavior for some queries
*** Translating predicates
**** member
*** Recursive goals should come last in a fresh or run, or within a conde clause
*** Non-recursive clauses should come first in a conde
*** Handling negation
**** =/= and other constraints
**** Helper relations
* PART II: WRITING THE RELATIONAL INTERPRETER
* A Call-by-value Lambda-Calculus Interpreter in Scheme
** The Call-by-value Lambda Calculus
the basis for Scheme
call-by-value, call-by-name, call-by-need
** Lexical Environments
** A First-order Lambda-Calculus Interpreter
[show first-order version]
*** Closures

[introduce LC first? then go to mk, then back to Scheme for list and
quote, then back to mk?  this would mirror the structure of the scheme
workshop quines paper]

[ugh--these sections don't seem organized correctly]
* Writing the Interpreter in Relational Style
* A Relational Scheme interpreter
'closure' as a "reserved" tag (using absento)
need to make sure to put this absento call in the right place
[arguably should be at the top of eval-expo, and invoked on each
recursive call; placing the call only in the evalo helper (for
example) means that direct calls to eval-expo may be incorrect]
* Beyond the Lambda Calculus
** Adding quote
[need to be very careful once we add quote and list, since we could
accidentally create lists that look like (and are treated as) lambda
expressions, etc.  Also, can end up with quoted closures, etc., unless
we were previously careful to exclude the 'closure' tag from the input
expression via absento]
** Adding list
[cons is actually simpler to add (since it doesn't require a recursive
helper, and since it doesn't overlap with the application clause),
although the quines it produces are longer than those with quote]
** (I love you)
** Generating Quines, Twines and Thrines
* Other Extensions to the Relational Interpreter
** Adding pair-related functions
*** cons
*** car & cdr
*** null?
*** Running append backwards
use Y combinator
runs backwards, forward, etc
slower, but with the same divergence behavior as the 'good' version of appendo
interesting aspect: the relational aspect is in the interpreter, not in the definition of append
** Adding numbers and arithmetic
*** Number representation
Oleg Numbers
little-endian binary lists
unique representation of each natural number
convention (not enforced by the arithmetic system): least significant bit is 1
well-formed/legal and illegal numbers
*** Arithmetic operators in miniKanren
*** Divergence behavior of the arithmetic system
Hilbert's 10th problem, Peano vs. Presburger (sp?) arithmetic, etc
*** Adding arithmetic to the interpreter
tagging/untagging/retagging
 'intc' (or whatever) as a "reserved" tag
(using absento) 
[? can we get away with the same tag for expressions and values?  or
do we need to make a distinction?  Need to be very careful with
tagging, especially in the presence of quote and list]
**** Example: factorial
**** Example: generating programs that evaluate to 6
*** Alternative approaches to relational arithmetic
**** Peano representation
**** CLP(fd)
** Adding multiple-argument and variadic functions
* Where to go from here
** Small-step reducer for Scheme
** Nominal logic programming
** Type inference
** Other experiments
