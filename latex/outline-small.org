OUTLINE FOR 'SMALL' BOOK--JUST INTRODUCING THE QUINES-GENERATING INTERPRETER

THE PRIME DIRECTIVE

Stick to the goal: ensure the reader fully understands how the
relational interpreter works.  in particular, the reader should be
able to modify or extend the relational interpreter, or implement a
relational interpreter for another langugae.  Anything that doesn't
advance this goal must be cut, put in a margin note, made an exercise,
or moved to an appendix.

MAJOR QUESTIONS/ISSUES

Do I want to include an mK implementation section?  I think not.  Want
to keep this a small, very directed book.

Seems like there a tension bewteen an overwhelming amount of detail,
and too much mystery.  I think I'll err on the too much mystery side
for now, then add the minimum relevant details once readers start
giving me feedback.

EXERCISES (might just turn some of these into actual sections of the book, with full explanations and derivations)

Scheme
------

miniKanren
----------

extending relational interpreter
--------------------------------

add null?, cons, car, cdr
then implement 'append' using Y combinator, and make it run backwards

add if

add letrec

add numbers, sub1, *, and implement factorial using Y combinator

implement an interpreter for a language other than Scheme

=================================


look at: dissertation, papers, summer school, miniKanren.org, blog
posts, core.logic pages, tutorials, videos of talks I've given, etc.

think about how I normally present these ideas to people

figure out which examples, and what code, goes where



Title:
How to Write a Relational Scheme Interpreter in miniKanren


* Preface
** Goal
ensure the reader fully understands how the relational interpreter
works.  in particular, the reader should be able to modify or extend
the relational interpreter, or implement a relational interpreter for
another langugae.  Anything that doesn't advance this goal has been
cut, put in a margin note, made an exercise, or moved to an appendix.
** Audience
for the small book, want to make it as accessible and self-contained
as possible.  for that reason, will start the book with a brief intro
to functional programming in Scheme, introducing only the minimal
aspects of the language needed to write and understand the relational
interpreter
** Running the code
[especially for this short book, might want to have all code runnable
online, using Nada's tech.  Could have this code/configuration/etc. in
a GitHub repo for posterity.  Of course, should also have code by
itself in a repo.  Ideally code should run under Vicare, Chez, Racket,
Gambit, Chicken, Larceny, etc.  Have compatibility modes for each
impl.  Might need some infrastructure so I can test code under
multiple imples from the command line]
** Typographical conventions
[can massage the typographical conventions text from my dissertation
(section 1.5)]
** miniKanren resources
** Margin notes
** Acknowledgements
* Just enough Scheme
* Introduction to core miniKanren
** The core operators
*** ==
*** run
*** fresh
*** conde
** Properties of reified answers
** Simple examples
** Fun with recursion
** Divergence
** Mixing Scheme and miniKanren

[got down to here.  after this, needs to be reworked]

* Translating simple Scheme functions to miniKanren relations
** append
hello world of logic programming
example of append in Scheme
add an 'o' to the name
add an 'out' argument (and why this is not the best name)
cond becomes conde
(null? l) becomes (== '())
values that were previously returned are now
run it forward
run it backwards, sideways, etc
divergence!
reordering of goals
** rember [aka, surpriseo!]
*** Errors are represented as failure
** An informal algorithm for translating Scheme programs to miniKanren
* Extended miniKanren
** =/=
*** rember reconsidered
can fix member in a similar fashion
** symbolo and numbero
** absento
* Hueristics for translating Scheme to miniKanren
*** Non-overlapping principle
*** Conde clauses that always fail can be removed
may improve divergence behavior for some queries
*** Translating predicates
**** member
*** Recursive goals should come last in a fresh or run, or within a conde clause
*** Non-recursive clauses should come first in a conde
*** Handling negation
**** =/= and other constraints
**** Helper relations
* A Simple Scheme Interpreter in Scheme
** Lexical scope
*** Free & Bound Variables
*** Lexical Environments
** A Simple Scheme Interpreter
* Writing the Interpreter in Relational Style
** Relational Scheme interpreter
* Extending the Relational Interpreter
** Adding quote
** Adding list
** (I love you)
** Generating Quines, Twines and Thrines
* Adding pair-related functions
** Adding null?
** Adding cons
** Adding car & cdr
** Running append backwards
use Y combinator
runs backwards, forward, etc
slower, but with the same divergence behavior as the 'good' version of appendo
interesting aspect: the relational aspect is in the interpreter, not in the definition of append
* Adding numbers to the interpreter
** Oleg numbers
** Arithmetic operators in miniKanren
** Divergence behavior of the arithmetic system
Hilbert's 10th problem, Peano vs. Presburger (sp?) arithmetic, etc
** Adding arithmetic to miniKanren
*** Example: factorial
*** Example: generating programs that evaluate to 6
** Alternative approaches to relational arithmetic
*** Peano representation
*** CLP(fd)
* Where to go from here
** Small-step reducer for Scheme
** Nominal logic programming
** Type inference
** Other experiments
